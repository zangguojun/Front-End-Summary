## 一、var变量

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>var</title>
    <script>
        window.onload = function () {
            var aLi = document.getElementsByTagName('li');
            for (let i = 0; i < aLi.length; i++) {　　/*单击任何标签都输出4*/
                aLi[i].onclick = function () {/*将var改为let*/
                    alert(i);　　　　
                }
            }
        }
    </script>
</head>

<body>
    <ul>
        <li>0</li>
        <li>1</li>
        <li>2</li>
        <li>3</li>
    </ul>
</body>

</html>
```

## 二、let变量

ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景，在ES6之前，大部分人会选择使用闭包来解决这个问题，今天我们使用ES6提供的let来解决这个问题。

代码大同小异，只需将上例子代码for循环中的var改为let，即可实现的效果是点击不同的<li>标签，alert出其对应的索引值。

let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说，let为其声明的变量隐式地了所在的块作用域。 

就是 `for`循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。

**var和let的区别**

var 和 let 第一点不同就是 let 是块作用域，即其在整个大括号 {} 之内可见。如果使用 let 来重写上面的 for 循环的话，会报错

var：只有全局作用域和函数作用域概念，没有块级作用域的概念。但是会把{}内也假称为块作用域。

let：只有块级作用域的概念 ，由 { } 包括起来，if语句和for语句里面的{ }也属于块级作用域。

### 1.函数作用域 vs 块级作用域

### 2.变量提升 vs 暂时性死区

let 和 var 的第二点不同是，在变量声明之前就访问变量的话，会直接提示 ReferenceError，而不像 var 那样使用默认值 undefined:

var 存在变量提升，而 let，const（后面会提及）声明的变量却不存在变量提升，所以用 let 定义的变量一定要在声明后再使用，否则会报错。

**ES6明确规定，如果区块中存在let命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。所以在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。**

```js
let a = 'outside';
if(true) {
   console.log(a);//Uncaught ReferenceError: a is not defined
   let a = "inside";
}
```

当前作用域顶部到该变量声明位置中间的部分，都是该let变量的死区，在**死区**中，**禁止访问该变量**。由此，我们给出结论，let声明的变量存在变量提升， 但是由于死区我们无法在声明前访问这个变量**。**

 **“暂时性死区”也意味着typeof不再是一个百分之百安全的操作，因为会使typeof报错**

```js
{
    typeof name;//ReferenceError
    let name;
}
```

只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。在代码块中，使用let命令声明变量之前，该变量都是不可用的，这在语法上称为“暂时性死亡”

### 3.let不允许重复声明变量

### 4.全局变量vs全局对象的属性

ES5中全局对象的属性与全局变量基本是等价的，但是也有区别，比如通过var声明的全局变量不能使用delete从 window/global （ global是针对与node环境）上删除，不过在变量的访问上基本等价。

ES6 中做了严格的区分，使用 **var 和 function 声明的全局变量依旧作为全局对象的属性**，使用 **`let`, `const`** 命令声明的全局变量**不属于全局对象的属性**。

 

## 三、const声明的常量

除了let以外，ES6还引入了cons，const 和 let 的作用域是一致的，不同的是 const 变量一旦被赋值，就不能再改变了，但是这并不意味着使用 const 声明的变量本身不可变，只是说它不可被再次赋值了，而且const 声明的变量**必须**经过**初始化。**

注：复合类型const变量保存的是引用。因为复合类型（如数组和对象）的常量不指向数据，而是指向数据(heap)所在的地址(stack)，所以通过 const 声明的复合类型只能保证其地址引用不变，但不能保证其数据不变。所以将一个对象声明为常量必须非常小心。

简单数据类型（数值，字符串，布尔值）：值保存在变量指向的那个内存地址，因此**等同于常量**。

复合类型的数据（对象和数组）：变量指向的是内存地址，保存的是一个指针，const只能保存这个指针地址是固定的，至于他指向的数据结构是不是可变的，就完全不能控制了。

但是什么时候用 var、let 或 const 呢？我的建议是，大多数情况下都使用 const，除非你知道你的变量的值还会被改变，以上大概是总结后的内容，看来，还是多用 let 、const 吧。





