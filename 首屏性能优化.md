## 一 什么是首屏？

以800x600像素尺寸为标准，当浏览器加载页面后看到第一眼的显示内容为首屏。而从开始加载到浏览器页面显示高度达到600像素且此区域有内容显示的时间为首屏显示时间。

以京东首页为例：![first](https://images2015.cnblogs.com/blog/890053/201703/890053-20170310154809545-1486134676.png)

当我们打开京东时，第一眼看到的内容即为首屏内容，也就是如上图的内容。

## 二 为什么要做首屏优化

一个页面的“总加载时间”要比“首屏时间”长，但对于最终用户体验而言，当内容充满首屏的区域时，用户就可以看到网站的主要内容并可以进行各自的选择了。首屏时间的快与慢，直接影响到了用户对网站的认知度。
所以首屏时间的长短对于用户的滞留时间的长短、用户转化率都尤为重要。

## 三 大公司是怎么做首屏优化的

还是首先以京东为例：

当我们打开京东的网站（不要滚动鼠标和键盘），右键查看源代码会发现京东首页的DOM树出奇的简单，页面DOM中多含有mod_lazyload的类

```html
<div class="J_f J_lazyload J_f_lift mod_lazyload need_ani chn" id="portal_8" data-backup="basic_8" data-source="cms:basic_8" data-tpl="portal_tpl">
```

再看下 localstorage

![img](https://images2015.cnblogs.com/blog/890053/201703/890053-20170310154834670-636385781.png)

尤其是观察location下面的键值对，会发现它们的值中多存在一串完整的类似于html的内容`(内容太多删除了值中的内容)`

![img](https://images2015.cnblogs.com/blog/890053/201703/890053-20170310154904342-1719853649.png)

由上面的结构我们可知jd.com已经将它们的页面结构放到了localstorage，不难想象这只是它页面中的其中一个模块的内容

分析到这里已经很明显了，通过前端缓存和异步加载jd已经完美的实现了首屏快速加载，在PC端达到了秒开的级别。

把需要请求的路径写在 dom 上（例如:data-tpl="elevator_tpl"），用户滚动时，一旦该模块进入了视窗，则请求 dom 上对应的 data-tpl 地址，拿到渲染这个模块所需要的脚本和数据，不过这中间还有一层本地缓存 localstorage，如果在本地缓存中匹配到了对应的 hash string 内容，则直接渲染，否则请求到数据之后更新本地缓存。localstorage中的 version 会在页面加载时候，与后端文件 hash相对比，hash不变直接取localstorage中的内容（当然也可以使用cookie判断版本）。

这里其实存在两个请求，一个请求是加载数据和脚本，而这里的内容是：

为啥不在返回的内容中直接把脚本也输出出来？为了让数据充分缓存下了不少功夫。数据的变化频率比较高，如果数据和初始化脚本包装在一起，虽然节约了一个请求，但一旦数据变化，整个脚本都得重新加载，而将数据和脚本分离，脚本可以长期缓存在本地，单独请求数据，这个量会小很多。直接改变上面的 version 版本号便可以让浏览器重新请求最新脚本。

从上面可以看出，任何一个模块的改动，在前端只会引起一个较小的加载变化，加上 http 的缓存策略，服务器的压力也是很小的。





