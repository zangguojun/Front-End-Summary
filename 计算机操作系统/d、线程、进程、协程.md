## 并发与并行

### **并发**：

在操作系统中，**某一时间段**，几个程序在同一个CPU上运行，但在**任意一个时间点**上，**只有一个程序在CPU上运行**。
当有**多个线程**时，如果系统**只有一个CPU**，那么CPU不可能**真正同时进行多个线程**，CPU的运行时间会被划分成若**干个时间段**，每个时间段**分配给各个线程**去执行，一个时间段里某个线程运行时，**其他线程处于挂起状态**，这就是并发。

> 并发解决了**程序排队等待**的问题，如果一个程序发生阻塞，其他程序仍然可以正常执行。

### **并行**：

当操作系统有多个CPU时，**一个CPU处理A线程**，**另一个CPU处理B线程**，两个线程互相不抢占CPU资源，可以同时进行，这种方式成为并行。

### 区别

1. 并发只是在**宏观上**给人感觉有**多个程序在同时运行**，但在实际的**单CPU系统**中，每一时刻只有一个程序在运行，微观上这些程序是**分时交替执行**。
2. 在**多CPU系统**中，将这些并发执行的程序分配到**不同的CPU**上处理，每个CPU用来处理一个程序，这样多个程序便可以实现**同时执行**。

### 理解

- 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你**不支持并发也不支持并行**。
- 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持**并发**。
- 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持**并行**。

**并发**的关键是你有        处理多个任务的能力，**不一定要同时**。

**并行**的关键是你有**同时**处理多个任务的能力。

所以我认为它们最关键的点就是：是否是**『同时』**。







______



## 进程

**一个进程好比是一个程序**，它是**资源分配**的最小单位 。**同一时刻执行的进程数不会超过核心数**。【不过如果问单核CPU能否运行多进程？答案又是肯定的。单核CPU也可以运行多进程，只不过不是同时的，而是极快地在**进程间来回切换**实现的多进程。举个简单的例子，就算是十年前的单核CPU的电脑，也可以聊QQ的同时看视频。】

电脑中有**许多进程**需要处于**「同时」**开启的状态，而利用**CPU在进程间的快速切换**，可以实现**「同时」**运行多个程序。而**进程切换**则意味着需要**保留进程切换前的状态**，以备切换回去的时候能够继续接着工作。所以**进程拥有**自己的**地址空间**，**全局变量**，**文件描述符**，**各种硬件**等等资源。操作系统通过**调度CPU**去执行**进程的记录**、**恢复**、**切换**等等。



经典定义：一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文中。（-摘自 CSAPP）

**进程是系统资源分配的最小单位**



## 线程

如果说进程和进程之间相当于程序与程序之间的关系，那么线程与线程之间就相当于程序内的任务和任务之间的关系。

所以**线程是依赖于进程的**，也称为 **「微进程」** 。它是**程序执行过程中的最小单元** 。



线程就是运行在进程上下文中的逻辑流。

**线程是操作系统能够进行运算调度的最小单位。**



一个程序内包含了多种任务。

打个比方，用播放器看视频的时候，视频输出的画面和声音可以认为是两种任务。当你拖动进度条的时候又触发了另外一种任务。拖动进度条会导致画面和声音都发生变化，如果进程里没有线程的话，那么可能发生的情况就是：**拖动进度条->画面更新->声音更新**。你会明显感到画面和声音和进度条不同步。但是加上了线程之后，**线程能够共享进程的大部分资源**，**并参与CPU的调度**。意味着它能够在**进程间进行切换**，**实现「并发」**，从而反馈到使用上就是拖动进度条的同时，画面和声音都同步了。所以我们经常能听到的一个词是**「多线程」**，就是把**一个程序分成多个任务去跑**，**让任务更快处理**。不过**线程和线程之间由于某些资源是独占的**，会导致锁的问题。例如**Python的GIL多线程锁**。



## 进程与线程的区别

1. 进程是**CPU资源分配的基本单位**，线程是独立运行和独立调度的基本单位（**CPU上真正运行的是线程**）。
2. 进程拥有自己的**资源空间**，一个进程包含若干个线程，**线程与CPU资源分配无关**，**多个线程共享同一进程内的资源**
3. **线程的调度与切换比进程快很多**。

**CPU密集型代码(各种循环处理、计算等等)：使用多进程。**

**IO密集型代码(文件处理、网络爬虫等)：使用多线程**



## 阻塞与非阻塞

阻塞是指**调用线程或者进程被操作系统挂起**。
非阻塞是指**调用线程或者进程不会被操作系统挂起。**



## 同步与异步

同步是**阻塞模式**，异步是**非阻塞模式**。



- **同步**就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个**进程将会一直等待下去**，知道收到返回信息才继续执行下去；
- **异步**是**指进程不需要一直等下去**，而是**继续执行下面的操作**，不管其他进程的状态。**当有消息返回式系统会通知进程进行处理**，这样可以**提高执行的效率**。

由**调用方**盲目**主动问询**的方式是同步调用

由**被调用方主动通知调用方任务已完成**的方式是异步调用。看下图

![img](https://pic4.zhimg.com/80/v2-f1118cbd6283a2626e6d4b9e7477b21b_720w.jpg)

## 协程

协程，又称**微线程**，纤程。英文名Coroutine。一句话说明什么是**协程**：**协程是一种用户态的轻量级线程。**

协程拥有**自己的寄存器上下文和栈**。**协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。**因此：
协程**能保留上一次调用时的状态**（即所有局部状态的一个特定组合），**每次过程重入时**，就相当于进入上一次调用的状态，换种说法：**进入上一次离开时所处逻辑流的位置。**

**好处**：

1. **无需线程上下文切换的开销**
2. **无需原子操作锁定及同步的开销**
3. **方便切换控制流，简化编程模型**

**高并发**+**高扩展性**+**低成本**：一个CPU支持上万的协程都不是问题。所以很适合**用于高并发处理**。

**缺点**：

1. **无法利用多核资源**：协程的本质是个单线程,它**不能同时将单个CPU的多个核用上**,**协程需要和进程配合才能运行在多CPU上**.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。
2. **进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序**



## 最佳实践

1. **线程和协程推荐在IO密集型的任务**(比如网络调用)中使用，而在**CPU密集型**的任务中，表现较差。
2. **对于CPU密集型的任务**，则需要多个进程，**绕开GIL的限制**，**利用所有可用的CPU核心**，提高效率。
3. **所以大并发下的最佳实践就是多进程+协程**，既充分利用多核，**又充分发挥协程的高效率**，可获得极高的性能。

顺便一提，非常流行的一个爬虫框架Scrapy就是用到异步框架Twisted来进行任务的调度，这也是Scrapy框架高性能的原因之一。







