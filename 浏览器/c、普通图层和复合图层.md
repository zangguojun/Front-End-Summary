## GPU中的各个复合图层是单独绘制的

渲染步骤中就提到了`composite`概念。

可以简单的这样理解，浏览器渲染的图层一般包含两大类：`普通图层`以及`复合图层`

首先，**普通文档流**内可以理解为一个复合图层（这里称为`默认复合层`，里面不管添加多少元素，其实都是在同一个复合图层中）

其次，**absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于`默认复合层`。**

然后，可以通过**`硬件加速`**的方式，**声明一个`新的复合图层`**，它会单独分配资源

（**当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化**，也不会影响`默认复合层`里的回流重绘）

可以简单理解下：**GPU中，各个复合图层是单独绘制的，所以互不影响**，这也是为什么**某些场景硬件加速效果**一级棒

可以`Chrome源码调试 -> More Tools -> Rendering -> Layer borders`中看到，黄色的就是复合图层信息

如下图。可以验证上述的说法

<img src="https://segmentfault.com/img/remote/1460000012925882" alt="img" style="zoom:150%;" />



## 如何变成复合图层（硬件加速）

将**该元素变成一个复合图层**，就是传说中的**硬件加速技术**

- 最常用的方式：`translate3d`、`translateZ`
- `opacity`属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
- `will-chang`属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层）。

作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）

- `<video><iframe><canvas><webgl>`等元素
- 其它，譬如以前的flash插件



## absolute和硬件加速的区别

可以看到，absolute虽然可以脱离普通文档流，但是**无法脱离默认复合层**。
所以，就算absolute中**信息改变**时**不会改变**普通文档流中**render树**，
但是，浏览器最终绘制时，是整个复合层绘制的，所以**absolute中信息的改变**，**仍然会影响整个复合层的绘制**。
（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）

而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层
（当然了，内部肯定会影响属于自己的复合层），仅仅是**引发最后的合成**（输出视图）



## 复合图层的作用？

一般一个**元素开启硬件加速后会变成复合图层**，可以**独立于普通文档流**中，改动后可以**避免整个页面重绘**，**提升性能**

但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡



## 硬件加速时请使用index

使用硬件加速时，**尽可能的使用index**，防止浏览器默认给**后续的元素创建复合层渲染**

具体的原理时这样的：
webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且relative或absolute属性相同的），
**会默认变为复合层渲染，如果处理不当会极大的影响性能**

简单点理解，其实可以认为是一个**隐式合成**的概念：**如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层**，这点需要特别注意





























