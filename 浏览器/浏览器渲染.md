## 浏览器渲染（详细版）

> 浏览器渲染页面的下载是自上而下的，渲染顺序也是自上而下的，下载与渲染同时进行；

+ (1)、如果HTTP响应报文是301或302重定向，则浏览器会相应头中的location再次发送请求

+ (2)、浏览器处理HTTP响应报文中的主体内容，首先使用loader模块加载相应的资源

  + loader模块有两条资源加载路径：主资源加载路径和派生资源加载路径。
    + 主资源即google主页的index.html文件 
    + 派生资源即index.html文件中用到的资源
  + 主资源到达后，浏览器的Parser模块解析主资源的内容，生成派生资源对应的DOM结构，然后根据需求触发派生资源的加载流程。比如，在解析过程中，如果遇到img的起始标签，会创建相应的image元素HTMLImageElement，接着依据img标签的内容设置HTMLImageElement的属性。在设置src属性时，会触发图片资源加载，发起加载资源请求
  + 这里常见的优化点是对派生资源使用缓存

+ (3)、使用parse模块解析HTML、CSS、Javascript资源

  + 解析HTML变成DOM树
    + HTML解析分为可以分为解码、分词、解析、建树四个步骤
    + （1）解码：将网络上接收到的经过编码的字节流，解码成Unicode字符
    + （2）分词：按照一定的切词规则，将Unicode字符流切成一个个的词语
    + （3）解析：根据词语的语义，创建相应的节点(Node)
    + （4）建树：将节点关联到一起，创建DOM树
    + ![img](https://images2015.cnblogs.com/blog/1034346/201703/1034346-20170329153234951-1328599578.png)
  + 解析CSS变成渲染树
    + ![img](https://images2015.cnblogs.com/blog/1034346/201703/1034346-20170329153247436-670728382.png)
  + 遇到JS时解析JS，解析完成后立即执行
    + JavaScript一般由单独的脚本引擎解析执行，它的作用通常是动态地改变DOM树（比如为DOM节点添加事件响应处理函数），即根据时间（timer）或事件（event）映射一棵DOM树到另一棵DOM树
    + 简单来说，经过了Parser模块的处理，浏览器把页面文本转换成了一棵节点带CSS Style、会响应自定义事件的Styled DOM树

+ (4)、构建DOM树、Render树及RenderLayer树

  > 浏览器的解析过程就是将字节流形式的网页内容构建成DOM树、Render树及RenderLayer树的过程

  > 使用parse解析HTML的过程，已经完成了DOM树的构建，接下来构建Render树

  + 【创建Render树】

    + Render树用于表示文档的可视信息，记录了文档中每个可视元素的布局及渲染方式
    + RenderObject是Render树所有节点的基类，作用类似于DOM树的Node类。这个类存储了绘制页面可视元素所需要的样式及布局信息，RenderObject对象及其子类都知道如何绘制自己。事实上绘制Render树的过程就是RenderObject按照一定顺序绘制自身的过程
    + DOM树上的节点与Render树上的节点并不是一一对应的。只有DOM树的根节点及可视节点才会创建对应的RenderObject节点

  + 【创建Render Layer树】

    + Render Layer树以层为节点组织文档的可视信息，网页上的每一层对应一个Render Layer对象。

    + RenderLayer树可以看作Render树的稀疏表示，每个RenderLayer树的节点都对应着一棵Render树的子树，这棵子树上所有Render节点都在网页的同一层显示

    + RenderLayer树是基于RenderObject树构建的，满足一定条件的RenderObject才会建立对应的RenderLayer节点

    + 下面是RenderLayer节点的创建条件：

      + （1）网页的root节点
      + （2）有显式的CSS position属性（relative，absolute，fixed）
      + （3）元素设置了transform
      + （4）元素是透明的，即opacity不等于1
      + （5）节点有溢出（overflow）、alpha mask或者反射（reflection）效果。
      + （6）元素有CSS filter（滤镜）属性
      + （7）2D Canvas或者WebGL
      + （8）Video元素

+ (5)、布局和渲染

  + 布局就是安排和计算页面中每个元素大小位置等几何信息的过程。HTML采用流式布局模型，基本的原则是页面元素在顺序遍历过程中依次按从左至右、从上至下的排列方式确定各自的位置区域

+ 简单情况下，布局可以顺序遍历一次Render树完成，但也有需要迭代的情况。当祖先元素的大小位置依赖于后代元素或者互相依赖时，一次遍历就无法完成布局，如Table元素的宽高未明确指定而其下某一子元素Tr指定其高度为父Table高度的30%的情况

  + Paint模块负责将Render树映射成可视的图形，它会遍历Render树调用每个Render节点的绘制方法将其内容显示在一块画布或者位图上，并最终呈现在浏览器应用窗口中成为用户看到的实际页面

+ 主要绘制顺序如下：

  + （1）背景颜色
  + （2）背景图片
  + （3）边框
  + （4）子呈现树节点
  + （5）轮廓

+ 6、硬件加速

  + 开启硬件渲染，即合成加速，会为需要单独绘制的每一层创建一个GraphicsLayer

![http](https://pic.xiaohuochai.site/blog/browserRender4.png)

## 浏览器渲染(简单版)

#### （1）浏览器渲染页面

+ 浏览器渲染页面的下载是自上而下的，渲染顺序也是自上而下的，下载与渲染同时进行；
+ 解析HTML变成DOM树；
+ 解析CSS变成渲染树；
+ 遇到JS时解析JS，解析完成后立即执行；

> （1，2同时进行，一边解析一边生成页面，会随着页面的内容不断调整）

【重绘和回流】

#### （2）关联资源的处理

+ 在渲染页面到某一部分时，其上面的所有部分（当前的HTML元素和CSS）都已下载完成；
+ 但是相关联的的元素不一定下载完成了（例如：图片，视屏等元素会并行下载）；
+ 同一个域名下并行下载数量有限制（有些网站图片等其他资源会放在另外的服务器上）；

#### （3）JS和AJAX

+ 下载解析JS时候是以阻塞的方式进行下载，下载JS时，浏览器在发送了请求后直到响应前都会阻塞其它资源的下载和渲染；
+ 可以用HTML5的异步下载属性（async和defer）
  + async：遇到JS后与其他资源一起下载，下载完成后执行；
  + defer：遇到JS后与其他资源一起下载，等所有资源下载完成后再去执行；
+ JS的阻塞性下载是因为JS有可能会改变DOM结构，导致页面重绘；
+ 遇到AJAX后执行，然后进行下面的步骤，等待AJAX拿到数据后再执行AJAX回调；

#### （4）CSS

+ CSS下载完成后，将和原先下载的所有样式表一起进行解析，解析完成后，将对此前所有元素（包含已经渲染过的元素）再渲染一遍；

+ JS、CSS如果有重定义，首先查看优先级，以优先级高的为主，若无优先级问题则浏览器以后定义的为主；

## 浏览器渲染(总结版)

### 1、解析文档构建DOM树

浏览器的解析内容可以分为三个部分：

+ HTML/XHTML/SVG：解析这三种文件后，会生成DOM树（DOM Tree）
+ CSS：解析样式表，生成CSS规则树（CSS Rule Tree）
+ JavaScript：解析脚本，通过DOM API和CSSOM API操作DOM Tree和CSS Rule Tree，与用户进行交互。

以上三类文件的执行顺序会根据其在文档中的位置及其标签属性的不同而有异同，具体在后文进行讨论。

### 2、构建渲染树

解析文档完成后，浏览器引擎会将 CSS Rule Tree 附着到DOM Tree 上，并根据DOM Tree 和 CSS Rule Tree构造 Rendering Tree（渲染树）。此处需要注意：

+ Render Tree和DOM Tree的区别在于，类似Head或display：node之类的东西不会放在渲染树中；
+ 将CSS Rule Tree匹配到DOM Tree需要解析CSS的选择器，为了提高该过程的性能，DOM树应该尽量小，CSS Selector应该尽量使用id和class，避免过度层叠。

### 3、布局与绘制渲染树

解析position, overflow, z-index等等属性，计算每一个渲染树节点的位置和大小，此过程被称为reflow。最后调用操作系统的Native GUI API完成绘制（repain）。注意：

- 渲染树的节点，在Gecko中称为frame，而在webkit中称为renderer；
- reflow和repaint是两个不同的概念，其区别会在后文进行探讨。

## 脚本和样式文件对页面渲染的影响

浏览器从服务器获取文档并从上到下进行解析，在脚本文件标签不包含defer和async属性的情况下，会按照如下规则执行文档内容：

- 解析html文档，遇到HTML标签时，构建DOM树
- 在构建DOM的过程中，如果遇到外联的样式声明或脚本声明，则暂停文档解析，创建新的网络连接，开始下载样式文件和脚本文件
- 样式文件下载完成后，构建CSS Rule DOM，脚本文件下载完成后，解释并立即执行。
- 构建DOM的同时，结合CSS规则树完成页面渲染。
- 如果DOM树先于CSS规则树构建完成，则在CSS规则树构建完成后，页面会发生一次重绘，将新构建的CSS规则应用于渲染树。

### （一）脚本文件对文档解析的影响

在这个过程中，脚本文件的下载和执行是与文档解析同步进行的，脚本文件的下载和执行都会阻塞文档的解析，如果控制得不好，在用户体验上就会造成一定程度的影响。举个例子，编写一个简单的html页面如下：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <script type="text/javascript" src="defer.js"></script>
</head>
<body>
    body render!
</body>
</html>
```

head中加载的脚本文件内容为：

```js
alert('i am the script');
```

在浏览器中运行时，会先弹出提示框，此时，body元素并没有进行渲染。

关闭弹出框以后，才完成对body的渲染：

![image-20210305202413487](https://cdn.jsdelivr.net/gh/zangguojun/PicGo/20210305202421.png)

#### 脚本文件的defer和async属性

为了防止脚本加载使浏览器页面阻塞，妨碍用户体验。应该合理使用`<script>`标签的defer属性和async属性。这两个属性用于调整脚本的下载和执行顺序，使其不阻塞页面加载。

##### defer：开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。

- defer只适用于外联脚本，如果script标签没有指定src属性，只是内联脚本，不要使用defer
- 如果有多个声明了defer的脚本，则会按顺序下载和执行
- defer脚本会在DOMContentLoaded和load事件之前执行

为了验证defer属性的相关规则，编写了如下测试代码：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <script type="text/javascript" src="defer1.js" defer></script>
    <script type="text/javascript" src="defer2.js" defer></script>
    <script type="text/javascript" defer>
        console.log('使用了defer属性的内联js')
    </script>
</head>
<body>
    <script type="text/javascript">
       document.addEventListener("DOMContentLoaded", function() {
           console.log('DOMContentLoaded');
       }, false);
       window.addEventListener('load', function() {
           console.log('onload');
       }, false);
    </script>
</body>
</html>
```

`defer1.js`：

```js
console.log('defer1')
```

`defer2.js`:

```js
console.log('defer2')
```

控制台输出结果如下图，可以看出，对内联js脚本使用defer属性并不起作用。

![这里写图片描述](https://img-blog.csdn.net/20180316100948629?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNjU3MDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

##### async：异步下载脚本文件，下载完毕立即解释执行代码。 HTML5的新增属性。

+ 只适用于外联脚本，这一点和defer一致
+ 如果有多个声明async的脚本，其下载和执行都是异步的，不能确保彼此的先后顺序
+ async会在load事件之前执行，但并不能确保与DOMContentLoaded的执行先后顺序

为了验证async属性的特性，编写页面如下：

```HTML
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <script type="text/javascript" src="async1.js" async></script>
    <script type="text/javascript" src="async2.js" async></script>
    <script type="text/javascript" async>
        console.log('使用了async属性的内联js')
    </script>
</head>
<body>
    <script type="text/javascript">
        document.addEventListener("DOMContentLoaded", function() {
           console.log('DOMContentLoaded');
       }, false);

       window.addEventListener('load', function() {
           console.log('onload');
       }, false);
    </script>
</body>
</html>
```

`async1.js`:

```js
console.log('async1.js')
```

`async2.js`:

```js
console.log('async2.js')
```

输出结果为：
![这里写图片描述](https://img-blog.csdn.net/20180316101735766?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNjU3MDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### 无任何特殊属性

下面这张图清楚的阐述了`<script>`脚本在无任何特殊属性、具有defer属性、具有async属性三种情况下的下载执行与文档解析的关系。其中绿色带包文档解析线程；蓝色代表脚本下载线程；红色代表脚本执行线程。

![这里写图片描述](https://img-blog.csdn.net/20160503104416135)

综上所述，defer属性和async属性都能防止脚本下载阻塞页面渲染。如果脚本之间没有依赖关系，可以使用async属性，如果脚本之间有依赖关系，应使用defer属性。如果同时使用async和defer属性，后者不起作用，浏览器行为由async属性决定。如果不想使用这两个属性，也可将<script>标签放在在</body>之前，达到同样的效果。

### （二）CSS对页面渲染的影响

> 前端页面渲染时会根据DOM结构生成一个DOM树,然后加上CSS样式生成渲染树。

+ 如果CSS文件放在`<head>`标签中，则CSS Rule Tree会先于DOM树完成构建，之后浏览器就可以边构建DOM树边完成渲染；

+ 反之，CSS文件放在所有页面标签之后，比如`<body/>`之后，那么当DOM树构建完成了，渲染树才构建，浏览器不得不再重新渲染整个页面，这样造成了资源的浪费。而且页面还可能会出现闪跳的感觉，或者白屏或者布局混乱或者样式很丑，直到CSS加载完成，页面重绘才能恢复正常。
+ 但如果css文件较大，会让首页白屏时间更长，所以并不是说把css都放顶部是一个完美的方法。权衡利弊，应该把必须的css（js）放顶部，把不那么重要的css（js）放底部。

## 浏览器渲染出现的问题

#### 白屏和FOUC问题

##### 白屏问题：

- 原因：
  - 先加载CSS，加载完成后再对HTML进行渲染，如果CSS加载时间过长，则导致白屏；
  - 使用@import，即使css放在link标签里，也有可能导致白屏；
  - 在IE浏览器下：css放置在页面底部，在某些场景下(新窗口打开,刷新等)页面会出现白屏,而不是内容逐步展现；
  - JS放置在头部阻塞后面内容的下载；

##### FOUC（无样式内容闪烁）

- 原因：
  - 因为浏览器渲染机制问题，再CSS加载之前，先呈现了HTML，就会出现逐步展示无样式内容，然后样式突然跳出来的问题；

总结：

- 如果等待CSS下载完成后才进行渲染，那么就有可能导致白屏；
- 如果先展示页面，等CSS下载完成后再渲染，就有可能导致FOUC问题；

解决：
 CSS放置在头部（head）里，JS放置在body之前；

#### onload事件和DOMContentLoaded事件

+ DOMContentLoaded事件是当初始HTML文档完全被加载和解析（即所有的DOM完全解析）时触发的，无需要等待样式表，图片，子框架完成加载。
+ 而onload事件要等页面所有元素，包括图片以及脚本等全部加载完成才触发，因此它比DOMContentLoaded要更晚执行。
+ 在页面的图片很多，网络不好的情况下，从用户访问到onload触发可能需要很长的时间，此时如果在onload中加入许多初始化的动作, 必然会影响用户的体验。这事使用DOMContentLoaded事件代替onload事件是更合适的。

#### 重绘和回流

+ Reflow，也称作Layout，中文回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为Reflow。
+ Repaint，中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就OK了，这个过程称为Repaint。
+ 所以说Reflow的成本比Repaint的成本高得多的多。DOM树里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。

+ 下面列举一些减少回流次数的方法

  + （1）不要一条一条地修改DOM样式，而是修改className或者修改style.cssText
  + （2）在内存中多次操作节点，完成后再添加到文档中去
  + （3）对于一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示
  + （4）在需要经常获取那些引起浏览器回流的属性值时，要缓存到变量中
  + （5）不要使用table布局，因为一个小改动可能会造成整个table重新布局。而且table渲染通常要3倍于同等元素时间
  + （6）此外，将需要多次重绘的元素独立为render layer渲染层，如设置absolute，可以减少重绘范围；
  + （7）对于一些进行动画的元素，可以进行硬件渲染，从而避免重绘和回流