#### 重绘和回流

+ Reflow，也称作Layout，中文回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为Reflow。
+ Repaint，中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就OK了，这个过程称为Repaint。
+ 所以说Reflow的成本比Repaint的成本高得多的多。DOM树里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。

+ 下面列举一些减少回流次数的方法

  + （1）不要一条一条地修改DOM样式，而是修改className或者修改style.cssText
  + （2）在内存中多次操作节点，完成后再添加到文档中去
  + （3）对于一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示
  + （4）在需要经常获取那些引起浏览器回流的属性值时，要缓存到变量中
  + （5）不要使用table布局，因为一个小改动可能会造成整个table重新布局。而且table渲染通常要3倍于同等元素时间
  + （6）此外，将需要多次重绘的元素独立为render layer渲染层，如设置absolute，可以减少重绘范围；
  + （7）对于一些进行动画的元素，可以进行硬件渲染，从而避免重绘和回流

### 插入几万个 DOM，如何实现页面不卡顿？

解决问题的重点应该是**如何分批次部分渲染** DOM。

- 通过 `requestAnimationFrame` 的方式去循环的插入 DOM；
- 通过虚拟滚动
- **这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。**
- 即使列表很长，但是渲染的 DOM 元素永远只有那么几个，当我们滚动页面的时候就会实时去更新 DOM。





## requestAnimationFrame 比起 

## setTimeout、setInterval的优势主要有两点：

1、requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。

2、在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。



### 不考虑缓存和优化网络协议的前提下，可以通过哪些方式来最快的渲染页面?

1. 从文件大小考虑
2. 从 `script` 标签使用上来考虑 async和differ
3. 从需要下载的内容是否需要在首屏使用上来考虑
4. 最后就是从 CSS、HTML 的代码书写上来考虑了

















