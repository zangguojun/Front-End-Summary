# 作用域链

#### 1、什么是作用域链

作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。

简单的说, **作用域是变量与函数的可访问范围.**

在ES6之前, 只有全局作用域和函数作用域， ES6中新增了块级作用域, 即两个大括号包裹的内部.

作用域可以嵌套. 在使用变量, 函数时, 对变量和函数的查找, 会先在当前的作用域中进行, 如果找不到的话会继续在包裹当前作用域的上级作用域中查找, 依次往上直到全局作用域. 这个查找过程不能反过来.

#### 2、作用域链的用途

是保证执行环境有权访问的所有变量和函数的有序访问。

#### 预解析

函数在执行的时候，会读取到整个函数内的关键字或参数。比如var、function、参数。读取过程中并不会读取到等号右边的代码。也就是说当读取到var的时候，其实是一种未定义的状态，读取到function的时候，是**将整个函数全部提取**； 

#### 逐行解读代码

预解析之后，就来**逐行解读代码**，**执行代码**；当在逐行解读的时候，**如果碰到函数调用，那么就会先解读函数内部的代码块**，这个时候就又会遵循函数作用域的执行过程。先解析，再解读。其中就涉及到全局变量和局部变量的操作。 逐行解读代码的一些原则：

1、逐行解读过程中，当碰到表达式的时候，就会用表达式修改预解析的值；表达式是=、+、-、*、/、参数（注意，参数也是表达式，参数可以被修改）

2、预解析的时候，遇到重名的变量名称，字母，值留下一个；

3、预解析时，当变量碰到函数的名称一致的时候，值留下函数块。因为预解析的时候，变量其实是未定义的状态

4、逐行解读代码时，碰到函数，如果没有调用，表示函数没有执行。此时直接略过，直到有表达式才能改变变量的值。

5、所有变量，在正式运行代码之前，都会提前赋一个值；未定义。所有函数，在预解析的时候，都是函数块；

6、逐行解读代码时，是从上到下，从函数内部到函数外部的执行过程

```js
alert(a);                
var a = 1;
alert(a);                  
function a (){ alert(2); }
alert(a);               
var a=3;     
alert(a);                   
function a (){ alert(4); }
alert(a);
```

上述这行代码，比较复杂，但我们依然按照作用域的解析过程来分析分析

1、预解析。找到关键字var和function。 从上到下，依次预解析的值有变化。先是第二行代码，var a是一种未定义；然后是第四行代码，是一个函数，此时函数a的值就覆盖了第二行代码的未定义；第六行变量依旧是未定义，修改不了；第八行是一个函数，此时就将第四行的函数块修改了。最后预解析保存的是第八行代码：function a (){ alert(4); }

2、逐行解读。

2-1、预解析过程后保存的代码是函数块，a=function a(){alert(4)}，此时执行第一行代码，alert（a），那么就会弹出第八行代码。function a(){alert(4)}

2-2、解读第二行代码，a=1，此时将函数代码块修改了，a=1，那么第三行代码则会弹出1；

2-3、解读到第四行代码，是一个函数，没有调用，也就没有表达式，直接跳过执行第五行代码，依然是a=1；

2-4、执行第六行代码，是一个表达式，将a修改为3；那么第七行代码就会弹出一个3

2-5、执行到第八行代码时，是一个函数块，依旧没有调用，直接跳过执行第九行代码，所有最后弹出依旧是3

所以最后的结果是：
```js
alert(a);					// function a (){ alert(4);}
var a = 1;
alert(a);					// 1
function a (){ alert(2); }
alert(a);					// 1
var a=3;		
alert(a);					// 3
function a (){ alert(4); }
alert(a);					// 3
```



## 原型链

1、什么是原型链
当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的`__proto__`隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的`__proto__`中查找，这样一层一层向上查找就会形成一个链式结构，我们称为**原型链**。
2、原型链的用途
主要是继承的作用，简单来说，继承，就是子类继承父类的方法和变量；原型上可以定义一些方法和变量；以这个原型建立的对象，可以使用原型方法和变量，从而实现继承。



# 区别

1. 作用域是对于变量而言，原型链是对于对象的属性。
2. 作用域链顶层是**window**，原型链顶层是**Object**。
3. 作用域是针对变量的，比如我们创建了一个函数A，函数A里面又包含了一个函数b，那么现在就有三个作用域：**全局作用域==>函数a作用域==>函数b作用域**，作用域的特点就是，先在自己的变量范围中查找，如果A找不到，就会沿着作用域往上找。
4. 原型链是针对构造函数的，比如我先创建了一个函数，然后通过一个变量new了这个函数，那么这个被new出来的对象就会继承创建出来的那个函数的属性，然后如果我**访问**new出来的这个**对象的某个属性**，但是我并没有在这个new出来的对象中定义这个变量，那么它就会往上（向创建出它的函数中）查找，这个查找的过程就叫做原型链。**Object ==> 构造函数1 ==> 构造函数2**









