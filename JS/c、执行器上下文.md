## 执行上下文（Execution Context）

**执行上下文可以理解为当前代码的运行环境。**在 JavaScript 中，运行环境主要包含了**全局环境**和**函数环境**。

在 JavaScript 代码运行过程中，最先进入的是全局环境，而在**函数被调用时**则进入相应的函数环境。全局环境和函数环境所对应的执行上下文我们分别称为**全局上下文**和**函数上下文**。

在一个 JavaScript 文件中，经常会有多个函数被调用，也就是说在 JavaScript 代码运行过程中很可能会产生多个执行上下文。

执行上下文是以栈的方式被存放起来的，我们称之为**执行上下文栈（Execution Context Stack）**。

**在 JavaScript 代码开始执行时，首先进入全局环境，此时全局上下文被创建并入栈，之后当调用函数时则进入相应的函数环境，此时相应函数上下文被创建并入栈，当处于栈顶的执行上下文代码执行完毕后，则会将其出栈。**



所以在执行上下文栈中，栈底永远是全局上下文，而栈顶则是当前正在执行的函数上下文。

```js
function fn2() {
  console.log('fn2')
}
function fn1() {
  console.log('fn1')
  fn2();
}
fn1();
```

> 运行上述代码，可以得到相应的输出，那么上述代码在执行过程中执行上下文栈的行为是怎样的呢？

```js
/* 伪代码 以数组来表示执行上下文栈  */
ECStack=[]

// 代码执行时最先进入全局环境，全局上下文被创建并入栈
ECStack.push(global_EC);

// fn1 被调用，fn1 函数上下文被创建并入栈
ECStack.push(fn1_EC);

// fn1 中调用 fn2，fn2 函数上下文被创建并入栈
ECStack.push(fn2_EC);

// fn2 执行完毕，fn2 函数上下文出栈
ECStack.pop();

// fn1 执行完毕，fn1 函数上下文出栈
ECStack.pop();

// 代码执行完毕，全局上下文出栈
ECStack.pop();
```



在一个执行上下文中，最重要的三个属性分别是**变量对象（Variable Object）**、**作用域链（Scope Chain）**和 **this 指向**。

我们可以采用如下方式表示:

```js
EC = {
  VO,
  SC,
  this
}
```

一个执行上下文的生命周期分为**创建**和**执行**阶段。创建阶段主要工作是**生成变量对象**、**建立作用域链**和**确定 this 指向**。而执行阶段主要工作是变量赋值以及执行其它代码等。



































